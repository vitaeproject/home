{"ast":null,"code":"'use strict';\n\nvar waterfall = require('async/waterfall');\n\nvar CID = require('cids');\n\nvar util = require('./util');\n\nexports = module.exports;\nexports.multicodec = 'dag-pb';\n/*\n * resolve: receives a path and a binary blob and returns the value on path,\n * throw if not possible. `binaryBlob` is the ProtocolBuffer encoded data.\n */\n\nexports.resolve = function (binaryBlob, path, callback) {\n  waterfall([function (cb) {\n    return util.deserialize(binaryBlob, cb);\n  }, function (node, cb) {\n    // Return the deserialized block if no path is given\n    if (!path) {\n      return callback(null, {\n        value: node,\n        remainderPath: ''\n      });\n    }\n\n    var split = path.split('/');\n\n    if (split[0] === 'Links') {\n      var remainderPath = ''; // all links\n\n      if (!split[1]) {\n        return cb(null, {\n          value: node.links.map(function (l) {\n            return l.toJSON();\n          }),\n          remainderPath: ''\n        });\n      } // select one link\n\n\n      var values = {}; // populate both index number and name to enable both cases\n      // for the resolver\n\n      node.links.forEach(function (l, i) {\n        var link = l.toJSON();\n        values[i] = {\n          hash: link.multihash,\n          name: link.name,\n          size: link.size // TODO by enabling something to resolve through link name, we are\n          // applying a transformation (a view) to the data, confirm if this\n          // is exactly what we want\n\n        };\n        values[link.name] = link.multihash;\n      });\n      var value = values[split[1]]; // if remainderPath exists, value needs to be CID\n\n      if (split[2] === 'Hash') {\n        value = {\n          '/': value.hash\n        };\n      } else if (split[2] === 'Tsize') {\n        value = {\n          '/': value.size\n        };\n      } else if (split[2] === 'Name') {\n        value = {\n          '/': value.name\n        };\n      }\n\n      remainderPath = split.slice(3).join('/');\n      cb(null, {\n        value: value,\n        remainderPath: remainderPath\n      });\n    } else if (split[0] === 'Data') {\n      cb(null, {\n        value: node.data,\n        remainderPath: ''\n      });\n    } else {\n      cb(new Error('path not available'));\n    }\n  }], callback);\n};\n/*\n * tree: returns a flattened array with paths: values of the project. options\n * is an object that can carry several options (i.e. nestness)\n */\n\n\nexports.tree = function (binaryBlob, options, callback) {\n  if (typeof options === 'function') {\n    callback = options;\n    options = {};\n  }\n\n  options = options || {};\n  util.deserialize(binaryBlob, function (err, node) {\n    if (err) {\n      return callback(err);\n    }\n\n    var paths = [];\n    paths.push('Links');\n    node.links.forEach(function (link, i) {\n      paths.push(\"Links/\".concat(i, \"/Name\"));\n      paths.push(\"Links/\".concat(i, \"/Tsize\"));\n      paths.push(\"Links/\".concat(i, \"/Hash\"));\n    });\n    paths.push('Data');\n    callback(null, paths);\n  });\n};\n/*\n * isLink: returns the Link if a given path in a binary blob is a Link,\n * false otherwise\n */\n\n\nexports.isLink = function (binaryBlob, path, callback) {\n  exports.resolve(binaryBlob, path, function (err, result) {\n    if (err) {\n      return callback(err);\n    }\n\n    if (result.remainderPath.length > 0) {\n      return callback(new Error('path out of scope'));\n    }\n\n    if (typeof result.value === 'object' && result.value['/']) {\n      var valid;\n\n      try {\n        valid = CID.isCID(new CID(result.value['/']));\n      } catch (err) {\n        valid = false;\n      }\n\n      if (valid) {\n        return callback(null, result.value);\n      }\n    }\n\n    callback(null, false);\n  });\n};","map":null,"metadata":{},"sourceType":"script"}